defdefslot(llvm::Type::TypeID) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values void half float double x86-fp80\n"
        << "fp128 ppc-fp128 label metadata\n"
        << "x86-mmx token integer function\n"
        << "struct array pointer vector\n"
        << ")\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}
BeginDefClassBuilderNode(llvm::Type) {
    slot(llvm::Type::TypeID, "type-id");
	slot(bool, "is-void-type");
	slot(bool, "is-half-type");
	slot(bool, "is-float-type");
	slot(bool, "is-double-type");
	slot(bool, "is-x86-fp80-type");
	slot(bool, "is-fp128-type");
	slot(bool, "is-ppc-fp128-type");
	slot(bool, "is-floating-point");
	slot(bool, "is-x86-mmx-type");
	slot(bool, "is-fp-or-fp-vector-type");
	slot(bool, "is-label-type");
	slot(bool, "is-metadata-type");
	slot(bool, "is-int-or-int-vector-type");
	slot(bool, "is-ptr-or-ptr-vector-type");
	slot(bool, "is-empty-type");
	slot(bool, "is-first-class-type");
	slot(bool, "is-single-value-type");
	slot(bool, "is-aggregate-type");
	slot(unsigned, "primitive-bit-size");
	slot(unsigned, "scalar-bit-size");
	slot(int, "fp-mantissa-width");
	slot(llvm::Type*, "scalar-type");
	slot(const llvm::fltSemantics&, "float-semantics");
	multislot(llvm::ArrayRef<llvm::Type*>, "sub-types");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::FunctionType) {
    call_defclass_parent(llvm::Type);
    multislot(llvm::ArrayRef<llvm::Type*>, "parameters");
    slot(llvm::Type*, "return-type");
    slot(bool, "is-var-arg");
    slot(unsigned, "num-parameters");
} 
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::IntegerType) {
    call_defclass_parent(llvm::Type);
    slot(unsigned, "bit-width");
    slot(unsigned, "bit-mask");
    slot(unsigned, "sign-bit");
    slot(llvm::APInt, "mask");
    slot(bool, "is-power-of-2-byte-width");
} 
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::CompositeType) {
    call_defclass_parent(llvm::Type);
    multislot(llvm::Type*, "indices");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::SequentialType) {
    call_defclass_parent(llvm::CompositeType);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::StructType) {
    call_defclass_parent(llvm::CompositeType);
    slot(bool, "is-packed");
    slot(bool, "is-literal");
    slot(bool, "is-opaque");
    slot(bool, "has-name");
    slot(llvm::StringRef, "title");
    multislot(llvm::ArrayRef<llvm::Type*> const, "elements");
    //slot(unsigned, "num-elements");
}
EndDefClassBuilderNode
BeginDefClassBuilderNode(llvm::ArrayType) {
    call_defclass_parent(llvm::SequentialType);
    //slot(unsigned, "num-elements");
}
EndDefClassBuilderNode
BeginDefClassBuilderNode(llvm::PointerType) {
    call_defclass_parent(llvm::SequentialType);
    slot(unsigned, "address-space");
}
EndDefClassBuilderNode
BeginDefClassBuilderNode(llvm::VectorType) {
    call_defclass_parent(llvm::SequentialType);
    //slot(unsigned, "num-elements");
    slot(unsigned, "bit-width");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::Value) {
    slot(llvm::Type*, "type");
    slot(bool, "has-name");
    slot(llvm::StringRef, "title");
    slot(llvm::ValueName*, "value-name");
    multislot(llvm::iterator_range<llvm::Value::const_use_iterator>, "uses");
    multislot(llvm::iterator_range<llvm::Value::const_user_iterator>, "users");
    slot(bool, "has-one-use");
    slot(bool, "has-value-handle");
    slot(bool, "is-used-by-metadata");
    slot(unsigned, "num-uses" );
    slot(unsigned, "value-id" );
    slot(unsigned, "raw-subclass-optional-data");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::User) {
    call_defclass_parent(llvm::Value);
    multislot(llvm::User::const_op_range, "operands");
    multislot(llvm::ArrayRef<const uint8_t>, "descriptor");
    multislot(llvm::iterator_range<llvm::User::value_op_iterator>, "operand-values");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::MetadataAsValue) {
    call_defclass_parent(llvm::Value);
    slot(llvm::Metadata*, "metadata");
}
EndDefClassBuilderNode

defdefslot(llvm::InlineAsm::AsmDialect) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values att intel)\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}
defdefslot(llvm::InlineAsm::ConstraintPrefix) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values is-input is-output is-clobber)\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}
defstring_defslot(const std::string&);
BeginDefClassBuilderNode(llvm::InlineAsm) {
    call_defclass_parent(llvm::Value);
    slot(bool, "has-side-effects");
    slot(bool, "is-align-stack");
    slot(llvm::InlineAsm::AsmDialect, "dialect");
    slot(llvm::FunctionType*, "function-type");
    slot(const std::string&, "asm-string");
    slot(const std::string&, "constraint-string");
}
EndDefClassBuilderNode
BeginDefClassBuilderNode(llvm::BasicBlock) {
    call_defclass_parent(llvm::Value);
    slot(llvm::Module*, "module");
    slot(llvm::TerminatorInst*, "terminator");
    multislot(const llvm::BasicBlock*, "successors");
    multislot(const llvm::BasicBlock*, "predecessors");
    slot(bool, "has-address-taken");
    slot(bool, "is-eh-pad");
    slot(bool, "is-landing-pad");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::Argument) {
    call_defclass_parent(llvm::Value);
    slot(unsigned, "arg-number");
    slot(bool, "has-non-null-attribute");
    slot(unsigned, "dereferenceable-bytes");
    slot(unsigned, "dereferenceable-or-null-bytes");
    slot(bool, "has-by-val-attribute");
    slot(bool, "has-by-val-or-in-alloca-attribute");
    slot(unsigned, "param-alignment");
    slot(bool, 	"has-nest-attribute");
    slot(bool, 	"has-no-alias-attribute");
    slot(bool, 	"has-no-capture-attribute");
    slot(bool, 	"has-struct-ret-attribute");
    slot(bool, 	"has-returned-attribute");
    slot(bool, 	"only-reads-memory");
    slot(bool, 	"has-in-alloca-attribute");
    slot(bool, 	"has-zext-attribute");
    slot(bool, 	"has-sext-attribute");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::Instruction) {
    call_defclass_parent(llvm::User);
    slot(llvm::Module*, "module");
    slot(unsigned, "opcode");
    slot(std::string, "opcode-name");
    slot(bool, "is-terminator");
    slot(bool, "is-binary-op");
    slot(bool, "is-shift");
    slot(bool, "is-cast");
    slot(bool, "is-logical-shift");
    slot(bool, "is-arithmetic-shift");
    slot(bool, "has-Metadata");
    slot(bool, "has-MetadataOtherThanDebugLoc");
    slot(bool, "hasUnsafeAlgebra");
    slot(bool, "hasNoNaNs");
    slot(bool, "hasNoInfs");
    slot(bool, "hasNoSignedZeros");
    slot(bool, "hasAllowReciprocal");
    //slot(llvm::FastMathFlags, "getFastMathFlags");
    slot(bool, "isAssociative");
    slot(bool, "isCommutative");
    slot(bool, "isIdempotent");
    slot(bool, "isNilpotent");
    slot(bool, "mayWriteToMemory");
    slot(bool, "mayReadFromMemory");
    slot(bool, "mayReadOrWriteMemory");
    slot(bool, "isAtomic");
    slot(bool, "mayThrow");
    slot(bool, "mayReturn");
    slot(bool, "mayHaveSideEffects");
    slot(bool, "isEHPad");

}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::Operator) {
    call_defclass_parent(llvm::User);
    slot(unsigned, "opcode");
}
EndDefClassBuilderNode

//BeginDefClassBuilderNode(llvm::BitCastOperator) {
//    call_defclass_parent(llvm::Operator);
//    slot(llvm::Type*, "source");
//    slot(llvm::Type*, "destination");
//}
//EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::GEPOperator) {
    call_defclass_parent(llvm::Operator);
    slot(bool, "is-in-bounds");
    slot(llvm::Value*, "pointer-operand");
    slot(llvm::Type*, "pointer-operand-type");
    slot(llvm::Type*, "source-element-type");
    slot(unsigned, "pointer-address-space");
    slot(unsigned, "num-indices");
    slot(bool, "has-indices");
    slot(bool, "has-all-zero-indices");
    slot(bool, "has-all-constant-indices");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::PtrToIntOperator) {
    call_defclass_parent(llvm::Operator);
    slot(llvm::Value*, "pointer-operand");
    slot(llvm::Type*, "pointer-operand-type");
    slot(unsigned, "pointer-address-space");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ZExtOperator) {
    call_defclass_parent(llvm::Operator);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::OverflowingBinaryOperator) {
    call_defclass_parent(llvm::Operator);
    slot(bool, "has-no-unsigned-wrap");
    slot(bool, "has-no-signed-wrap");
}
EndDefClassBuilderNode

defdefslot(float) {
    str << "(slot " << name << "\n"
        << "(type FLOAT)\n"
        << "(visibility public))\n";
}
BeginDefClassBuilderNode(llvm::FPMathOperator) {
    call_defclass_parent(llvm::Operator);
    slot(bool, "hasUnsafeAlgebra");
    slot(bool, "hasNoNaNs");
    slot(bool, "hasNoInfs");
    slot(bool, "hasNoSignedZeros");
    slot(bool, "hasAllowReciprocal");
    //slot(llvm::FastMathFlags, "getFastMathFlags");
    slot(float, "fp-accuracy");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::PossiblyExactOperator) {
    call_defclass_parent(llvm::Operator);
    slot(bool, "is-exact");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::AddOperator) {
    call_defclass_parent(llvm::OverflowingBinaryOperator);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::MulOperator) {
    call_defclass_parent(llvm::OverflowingBinaryOperator);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ShlOperator) {
    call_defclass_parent(llvm::OverflowingBinaryOperator);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::SubOperator) {
    call_defclass_parent(llvm::OverflowingBinaryOperator);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::AShrOperator) {
    call_defclass_parent(llvm::PossiblyExactOperator);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::LShrOperator) {
    call_defclass_parent(llvm::PossiblyExactOperator);
}
EndDefClassBuilderNode
BeginDefClassBuilderNode(llvm::SDivOperator) {
    call_defclass_parent(llvm::PossiblyExactOperator);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::UDivOperator) {
    call_defclass_parent(llvm::PossiblyExactOperator);
}
EndDefClassBuilderNode
defdefslot(llvm::Constant::PossibleRelocationsTy) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values no-relocation local-relocation global-relocations)\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}
BeginDefClassBuilderNode(llvm::Constant) {
    call_defclass_parent(llvm::User);
    slot(bool , "isNullValue");
    slot(bool , "isOneValue");
    slot(bool , "isAllOnesValue");
    slot(bool , "isNegativeZeroValue");
    slot(bool , "isZeroValue");
    slot(bool , "isNotMinSignedValue");
    slot(bool , "isMinSignedValue");
    slot(bool , "canTrap");
    slot(bool , "isThreadDependent");
    slot(bool , "isDLLImportDependent");
    slot(bool , "isConstantUsed");
    slot(llvm::Constant::PossibleRelocationsTy , "RelocationInfo");
    slot(llvm::Constant * , "SplatValue");
    slot(const llvm::APInt & , "UniqueInteger");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::BlockAddress) {
    call_defclass_parent(llvm::Constant);
    slot(llvm::Function*, "function");
    slot(llvm::BasicBlock*, "basic-block");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantAggregateZero) {
    call_defclass_parent(llvm::Constant);
    slot(llvm::Constant * , "SequentialElement");
    slot(unsigned , "NumElements");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantArray) {
    call_defclass_parent(llvm::Constant);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantDataSequential) {
    call_defclass_parent(llvm::Constant);
    slot(llvm::Type * , "getElementType");
    slot(unsigned , "getNumElements");
    slot(unsigned, "getElementByteSize");
    slot(bool , "isString");
    slot(bool , "isCString");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantExpr) {
    call_defclass_parent(llvm::Constant);
    slot(bool , "isCast");
    slot(bool , "isCompare");
    slot(bool , "hasIndices");
    slot(bool , "isGEPWithNoNotionalOverIndexing");
    slot(unsigned , "opcode");
    slot(unsigned , "predicate");
    multislot(llvm::ArrayRef<unsigned>, "indices");
    slot(std::string, "opcode-name");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantFP) {
    call_defclass_parent(llvm::Constant);
    slot(const llvm::APFloat &, "float-value");
    slot(bool , "isZero");
    slot(bool , "isNegative");
    slot(bool , "isInfinity");
    slot(bool , "isNaN");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantInt) {
    call_defclass_parent(llvm::Constant);
    slot(const llvm::APInt & , "int-value");
    slot(unsigned , "BitWidth");
    slot(unsigned, "ZExtValue");
    slot(int, "SExtValue");
    slot(bool , "isNegative");
    slot(bool , "isZero");
    slot(bool , "isOne");
    slot(bool , "isMinusOne");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantPointerNull) {
    call_defclass_parent(llvm::Constant);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantStruct) {
    call_defclass_parent(llvm::Constant);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantVector) {
    call_defclass_parent(llvm::Constant);
    slot(llvm::Constant*, "splat-value");
}
EndDefClassBuilderNode


BeginDefClassBuilderNode(llvm::UndefValue) {
    call_defclass_parent(llvm::Constant);
    slot(llvm::UndefValue*, "sequential-element");
    slot(unsigned, "num-elements");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantDataArray) {
    call_defclass_parent(llvm::ConstantDataSequential);
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::ConstantDataVector) {
    call_defclass_parent(llvm::ConstantDataSequential);
    slot(llvm::Constant*, "splat-value");
}
EndDefClassBuilderNode
#define SimpleDefClassBuilder(type, parent) \
    BeginDefClassBuilderNode(type) { \
        call_defclass_parent(parent); \
    } EndDefClassBuilderNode

defdefslot(llvm::GlobalValue::LinkageTypes) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values external-linkage available-externally link-once-any link-once-odr\n"
        << "                weak-any weak-odr appending internal private external-weak common)\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}
defdefslot(llvm::GlobalValue::VisibilityTypes) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values default hidden protected)\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}

defdefslot(llvm::GlobalValue::DLLStorageClassTypes) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values default dll-import dll-export)\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}
defdefslot(llvm::GlobalValue::ThreadLocalMode) {
    str << "(slot " << name << "\n"
        << "(type SYMBOL)\n"
        << "(allowed-values not-thread-local general-dynamic-tls-model\n"
        << "                local-dynamic-tls-model initial-exec-tls-model\n"
        << "                local-exec-tls-model)\n"
        << "(storage local)\n"
        << "(visibility public))\n";
}
BeginDefClassBuilderNode(llvm::GlobalValue) {
    call_defclass_parent(llvm::Constant);
    slot(unsigned , "getAlignment");
    slot(bool , "hasUnnamedAddr");
    slot(bool , "hasComdat");
    slot(const llvm::Comdat * , "Comdat");
    slot(llvm::GlobalValue::VisibilityTypes , "Visibility");
    slot(bool , "hasDefaultVisibility");
    slot(bool , "hasHiddenVisibility");
    slot(bool , "hasProtectedVisibility");
    slot(bool , "isThreadLocal");
    slot(llvm::GlobalValue::ThreadLocalMode , "ThreadLocalMode");
    slot(llvm::GlobalValue::DLLStorageClassTypes , "DLLStorageClass");
    slot(bool , "hasDLLImportStorageClass");
    slot(bool , "hasDLLExportStorageClass");
    slot(bool , "hasSection");
    slot(std::string , "Section");
    slot(llvm::Type * , "ValueType");
    slot(bool , "hasExternalLinkage");
    slot(bool , "hasAvailableExternallyLinkage");
    slot(bool , "hasLinkOnceLinkage");
    slot(bool , "hasLinkOnceODRLinkage");
    slot(bool , "hasWeakLinkage");
    slot(bool , "hasWeakAnyLinkage");
    slot(bool , "hasWeakODRLinkage");
    slot(bool , "hasAppendingLinkage");
    slot(bool , "hasInternalLinkage");
    slot(bool , "hasPrivateLinkage");
    slot(bool , "hasLocalLinkage");
    slot(bool , "hasExternalWeakLinkage");
    slot(bool , "hasCommonLinkage");
    slot(llvm::GlobalValue::LinkageTypes , "Linkage");
    slot(bool , "isDiscardableIfUnused");
    slot(bool , "mayBeOverridden");
    slot(bool , "isWeakForLinker");
    slot(bool , "isDeclaration");
    slot(bool , "isDeclarationForLinker");
    slot(bool , "isStrongDefinitionForLinker");
    slot(bool , "is-materializable");
    slot(bool , "is-dematerializable");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::GlobalAlias) {
    call_defclass_parent(llvm::GlobalValue);
    slot(llvm::Constant*, "aliasee");
    slot(llvm::GlobalObject*, "base-object");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::GlobalObject) {
    call_defclass_parent(llvm::GlobalValue);
    slot(unsigned, "global-object-sub-class-data");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::Function) {
    call_defclass_parent(llvm::GlobalObject);
    slot(bool , "hasPersonalityFn");
    slot(llvm::Constant * , "PersonalityFn");
    slot(llvm::Type * , "ReturnType");
    slot(llvm::FunctionType * , "FunctionType");
    slot(bool , "isVarArg");
    slot(bool , "isMaterializable");
    slot(llvm::Intrinsic::ID , "IntrinsicID");
    slot(bool , "isIntrinsic");
    slot(llvm::CallingConv::ID , "CallingConv");
    slot(llvm::Optional< uint64_t > , "EntryCount");
    slot(unsigned , "FnStackAlignment");
    slot(bool , "hasGC");
    slot(std::string , "GC");
    slot(bool , "doesNotAccessMemory");
    slot(bool , "onlyReadsMemory");
    slot(bool , "onlyAccessesArgMemory");
    slot(bool , "doesNotReturn");
    slot(bool , "doesNotThrow");
    slot(bool , "cannotDuplicate");
    slot(bool , "isConvergent");
    slot(bool , "hasUWTable");
    slot(bool , "needsUnwindTableEntry");
    slot(bool , "hasStructRetAttr");
    slot(bool , "optForMinSize");
    slot(bool , "optForSize");
    multislot(const llvm::Function::ArgumentListType & , "ArgumentList");
    multislot(const llvm::Function::BasicBlockListType & , "BasicBlockList");
    slot(const llvm::BasicBlock & , "EntryBlock");
    multislot(const llvm::ValueSymbolTable & , "ValueSymbolTable");
    slot(bool , "hasPrefixData");
    slot(llvm::Constant * , "PrefixData");
    slot(bool , "hasPrologueData");
    slot(llvm::Constant * , "PrologueData");
    slot(bool , "isDefTriviallyDead");
    slot(bool , "callsFunctionThatReturnsTwice");
    slot(bool , "hasMetadata");
    //slot(llvm::DISubprogram * , "Subprogram");
}
EndDefClassBuilderNode

BeginDefClassBuilderNode(llvm::GlobalVariable) {
    call_defclass_parent(llvm::GlobalObject);
    slot(bool , "hasInitializer");
    slot(bool , "hasDefinitiveInitializer");
    slot(bool , "hasUniqueInitializer");
    slot(const llvm::Constant * , "initializer");
    slot(bool , "isConstant");
    slot(bool , "isExternallyInitialized");
}
EndDefClassBuilderNode
